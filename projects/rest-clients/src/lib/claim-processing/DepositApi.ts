/**
 * fox-claims
 * Monolithic-style application containing generated components from legacy code modernization and custom developed APIs to support core claim processing.
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import {HttpClient, HttpEvent, HttpHeaders, HttpParams, HttpResponse} from '@angular/common/http';
import {Inject, Injectable, Optional} from '@angular/core';
import {Observable} from 'rxjs';
import {Configuration} from '../configuration';
import {CustomHttpUrlEncodingCodec} from '../encoder';
import {BASE_PATH} from '../variables';
import {DepositConfirmationVO} from '../bpm-mediator/model/DepositConfirmationVO';
import {DepositSummaryVO} from './model/DepositSummaryVO';
import {DepositTreasuryReconciliationVO} from './model/DepositTreasuryReconciliationVO';
import {PagedResourcesOfResourceListOfDepositSummaryVO} from './model/PagedResourcesOfResourceListOfDepositSummaryVO';
import {PagedResourcesOfResourceOfDepositVO} from './model/PagedResourcesOfResourceOfDepositVO';
import {ResourceOfManualDepositVO} from './model/ResourceOfManualDepositVO';
import {ResourcesListOfResourceOfDepositQueueDetailsVO} from './model/ResourcesListOfResourceOfDepositQueueDetailsVO';

@Injectable({
  providedIn: 'root'
})
export class DepositApi {
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();

  protected basePath = '';

  constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
    }
  }

  /**
   * Select the correct content-type to use for a request.
   * Uses {@link Configuration#isJsonMime} to determine the correct content-type.
   * If no content type is found return the first found type if the contentTypes is not empty
   * @param contentTypes - the array of content types that are available for selection
   * @returns the selected content-type or <code>undefined</code> if no selection could be made.
   */
  public selectHeaderContentType(contentTypes: string[]): string | undefined {
    if (contentTypes.length === 0) {
      return undefined;
    }

    const type = contentTypes.find(x => this.isJsonMime(x));
    if (type === undefined) {
      return contentTypes[0];
    }
    return type;
  }

  /**
   * Select the correct accept content-type to use for a request.
   * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.
   * If no content type is found return the first found type if the contentTypes is not empty
   * @param accepts - the array of content types that are available for selection.
   * @returns the selected content-type or <code>undefined</code> if no selection could be made.
   */
  public selectHeaderAccept(accepts: string[]): string | undefined {
    if (accepts.length === 0) {
      return undefined;
    }

    const type = accepts.find(x => this.isJsonMime(x));
    if (type === undefined) {
      return accepts[0];
    }
    return type;
  }

  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  public isJsonMime(mime: string): boolean {
    const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
    return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
  }

  /**
   * Create a Manual Deposit
   * To create a manual deposit entry
   * @param deposit To create a new manual deposit entry
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createManualDeposit(deposit: ResourceOfManualDepositVO, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<ResourceOfManualDepositVO>;
  public createManualDeposit(deposit: ResourceOfManualDepositVO, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResourceOfManualDepositVO>>;
  public createManualDeposit(deposit: ResourceOfManualDepositVO, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResourceOfManualDepositVO>>;
  public createManualDeposit(deposit: ResourceOfManualDepositVO, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (deposit === null || deposit === undefined) {
      throw new Error('Required parameter deposit was null or undefined when calling createManualDeposit.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (OAuth2) required
    // oauth required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;

      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<ResourceOfManualDepositVO>(`${this.basePath}/api/deposit/manual`,
      deposit,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Find Deposits
   * To query Deposits by parameters
   * @param requestCorrelationId Initial Request GUID
   * @param depositCheckClaimNumber deposit check claim number
   * @param checkAmount deposit check amount
   * @param depositDate check deposit date
   * @param checkNumber check number
   * @param depositSource Source of the deposit
   * @param depositStatus Status of the deposit
   * @param size List Size
   * @param page Page Number
   * @param sortBy sorting parameter
   * @param orderBy ordering parameter
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findDeposit(requestCorrelationId?: string, depositCheckClaimNumber?: number, checkAmount?: string, depositDate?: string, checkNumber?: number, depositSource?: string, depositStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesOfResourceOfDepositVO>;
  public findDeposit(requestCorrelationId?: string, depositCheckClaimNumber?: number, checkAmount?: string, depositDate?: string, checkNumber?: number, depositSource?: string, depositStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesOfResourceOfDepositVO>>;
  public findDeposit(requestCorrelationId?: string, depositCheckClaimNumber?: number, checkAmount?: string, depositDate?: string, checkNumber?: number, depositSource?: string, depositStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesOfResourceOfDepositVO>>;
  public findDeposit(requestCorrelationId?: string, depositCheckClaimNumber?: number, checkAmount?: string, depositDate?: string, checkNumber?: number, depositSource?: string, depositStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    let queryParameters = new HttpParams();
    if (depositCheckClaimNumber !== undefined && depositCheckClaimNumber !== null) {
      queryParameters = queryParameters.set('deposit_check_claim_number', <any>depositCheckClaimNumber);
    }
    if (checkAmount !== undefined && checkAmount !== null) {
      queryParameters = queryParameters.set('check_amount', <any>checkAmount);
    }
    if (depositDate !== undefined && depositDate !== null) {
      queryParameters = queryParameters.set('deposit_date', <any>depositDate);
    }
    if (checkNumber !== undefined && checkNumber !== null) {
      queryParameters = queryParameters.set('check_number', <any>checkNumber);
    }
    if (depositSource !== undefined && depositSource !== null) {
      queryParameters = queryParameters.set('deposit_source', <any>depositSource);
    }
    if (depositStatus !== undefined && depositStatus !== null) {
      queryParameters = queryParameters.set('deposit_status', <any>depositStatus);
    }
    if (size !== undefined && size !== null) {
      queryParameters = queryParameters.set('size', <any>size);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (sortBy !== undefined && sortBy !== null) {
      queryParameters = queryParameters.set('sort_by', <any>sortBy);
    }
    if (orderBy !== undefined && orderBy !== null) {
      queryParameters = queryParameters.set('order_by', <any>orderBy);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (OAuth2) required
    // oauth required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesOfResourceOfDepositVO>(`${this.basePath}/api/deposit`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Find Deposit Summary
   * To query Deposit Summaries by parameters
   * @param requestCorrelationId Initial Request GUID
   * @param depositSummaryFrom deposit summary received from date
   * @param depositSummaryTo deposit summary received to date
   * @param depositSource Source of the deposit file
   * @param depositStatus Status of the deposit summary
   * @param size List Size
   * @param page Page Number
   * @param sortBy sorting parameter
   * @param orderBy ordering parameter
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findDepositSummary(requestCorrelationId?: string, depositSummaryFrom?: string, depositSummaryTo?: string, depositSource?: string, depositStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesOfResourceListOfDepositSummaryVO>;
  public findDepositSummary(requestCorrelationId?: string, depositSummaryFrom?: string, depositSummaryTo?: string, depositSource?: string, depositStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesOfResourceListOfDepositSummaryVO>>;
  public findDepositSummary(requestCorrelationId?: string, depositSummaryFrom?: string, depositSummaryTo?: string, depositSource?: string, depositStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesOfResourceListOfDepositSummaryVO>>;
  public findDepositSummary(requestCorrelationId?: string, depositSummaryFrom?: string, depositSummaryTo?: string, depositSource?: string, depositStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (depositSummaryFrom !== undefined) {
      queryParameters = queryParameters.set('deposit_summary_from', <any>depositSummaryFrom);
    }
    if (depositSummaryTo !== undefined) {
      queryParameters = queryParameters.set('deposit_summary_to', <any>depositSummaryTo);
    }
    if (depositSource !== undefined) {
      queryParameters = queryParameters.set('deposit_source', <any>depositSource);
    }
    if (depositStatus !== undefined) {
      queryParameters = queryParameters.set('deposit_status', <any>depositStatus);
    }
    if (size !== undefined) {
      queryParameters = queryParameters.set('size', <any>size);
    }
    if (page !== undefined) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (sortBy !== undefined) {
      queryParameters = queryParameters.set('sort_by', <any>sortBy);
    }
    if (orderBy !== undefined) {
      queryParameters = queryParameters.set('order_by', <any>orderBy);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesOfResourceListOfDepositSummaryVO>(`${this.basePath}/api/deposit/summary`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Get a Deposit
   * To retrieve a deposit record by deposit id
   * @param depositDetailId Deposit Id
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getDeposit(depositDetailId: number, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<DepositTreasuryReconciliationVO>;
  public getDeposit(depositDetailId: number, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DepositTreasuryReconciliationVO>>;
  public getDeposit(depositDetailId: number, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DepositTreasuryReconciliationVO>>;
  public getDeposit(depositDetailId: number, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (depositDetailId === null || depositDetailId === undefined) {
      throw new Error('Required parameter depositDetailId was null or undefined when calling getDeposit.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<Array<DepositTreasuryReconciliationVO>>(`${this.basePath}/api/deposit/${encodeURIComponent(String(depositDetailId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Get queue details
   * To retrieve information needed for creating work queue items
   * @param depositSummaryId Deposit Summary Id
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getQueueDetails(depositSummaryId: number, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<ResourcesListOfResourceOfDepositQueueDetailsVO>;
  public getQueueDetails(depositSummaryId: number, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResourcesListOfResourceOfDepositQueueDetailsVO>>;
  public getQueueDetails(depositSummaryId: number, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResourcesListOfResourceOfDepositQueueDetailsVO>>;
  public getQueueDetails(depositSummaryId: number, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (depositSummaryId === null || depositSummaryId === undefined) {
      throw new Error('Required parameter depositSummaryId was null or undefined when calling getQueueDetails.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<ResourcesListOfResourceOfDepositQueueDetailsVO>(`${this.basePath}/api/deposit/${encodeURIComponent(String(depositSummaryId))}/queue_details`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Update a Deposit Summary Status
   * To update a deposit summary record verfication status
   * @param depositSummaryId Deposit Summary Id
   * @param depositFileStatus To create a new manual deposit entry
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateDepositSummaryStatus(depositSummaryId: number, depositFileStatus: DepositConfirmationVO, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<DepositSummaryVO>;
  public updateDepositSummaryStatus(depositSummaryId: number, depositFileStatus: DepositConfirmationVO, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DepositSummaryVO>>;
  public updateDepositSummaryStatus(depositSummaryId: number, depositFileStatus: DepositConfirmationVO, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DepositSummaryVO>>;
  public updateDepositSummaryStatus(depositSummaryId: number, depositFileStatus: DepositConfirmationVO, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (depositSummaryId === null || depositSummaryId === undefined) {
      throw new Error('Required parameter depositSummaryId was null or undefined when calling updateDepositSummaryStatus.');
    }
    if (depositFileStatus === null || depositFileStatus === undefined) {
      throw new Error('Required parameter depositFileStatus was null or undefined when calling updateDepositSummaryStatus.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string
      | undefined = this.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string
      | undefined = this.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.put<DepositSummaryVO>(`${this.basePath}/api/deposit/summary/${encodeURIComponent(String(depositSummaryId))}/status`,
      depositFileStatus,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }

}
