/**
 * fox-claims
 * Monolithic-style application containing generated components from legacy code modernization and custom developed APIs to support core claim processing.
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import {HttpClient, HttpEvent, HttpHeaders, HttpParams, HttpResponse} from '@angular/common/http';
import {Inject, Injectable, Optional} from '@angular/core';

import {Observable} from 'rxjs';
import {Configuration} from '../configuration';
import {CustomHttpUrlEncodingCodec} from '../encoder';
import {BASE_PATH} from '../variables';
import {ClaimHistoryAchPaymentVO} from './model/ClaimHistoryAchPaymentVO';
import {ClaimHistoryAuditVO} from './model/ClaimHistoryAuditVO';
import {ClaimHistorySendReplaceEobRaEligibleVO} from './model/ClaimHistorySendReplaceEobRaEligibleVO';
import {CrossReferenceVO} from './model/CrossReferenceVO';
import {PagedResourcesOfResourceOfClaimBillLineDetailsVO} from './model/PagedResourcesOfResourceOfClaimBillLineDetailsVO';
import {PagedResourcesOfResourceOfClaimBillLineVO} from './model/PagedResourcesOfResourceOfClaimBillLineVO';
import {PagedResourcesOfResourceOfClaimHistoryBillLineMessagesVO} from './model/PagedResourcesOfResourceOfClaimHistoryBillLineMessagesVO';
import {PagedResourcesOfResourceOfClaimHistoryClaimMessagesVO} from './model/PagedResourcesOfResourceOfClaimHistoryClaimMessagesVO';
import {PagedResourcesOfResourceOfClaimHistoryMemberVO} from './model/PagedResourcesOfResourceOfClaimHistoryMemberVO';
import {PagedResourcesOfResourceOfClaimHistoryVO} from './model/PagedResourcesOfResourceOfClaimHistoryVO';
import {PagedResourcesOfResourcesListOfResourceOfClaimHistorySendReplaceEobRaEligibleVO} from './model/PagedResourcesOfResourcesListOfResourceOfClaimHistorySendReplaceEobRaEligibleVO';
import {PagedResourcesOfResourcesListOfResourceOfCrossReferenceVO} from './model/PagedResourcesOfResourcesListOfResourceOfCrossReferenceVO';
import {ResourceOfClaimHistoryDetailVO} from './model/ResourceOfClaimHistoryDetailVO';
import {ResourcesListOfResourceOfSendReplaceConfirmationVO} from './model/ResourcesListOfResourceOfSendReplaceConfirmationVO';
import {TransferClaimVO} from './model/TransferClaimVO';
import {PagedResourcesofResourceOfClaimHistMaintHistVO} from './model/PagedResourcesofResourceOfClaimHistMaintHistVO';
import {ClaimLockVO} from './model/ClaimLockVO';
import {PagedResourcesofResourceOfDisplayRequestVO} from './model/PagedResourcesofResourceOfDisplayRequestVO';
import {PagedResourcesofCombinedClaimVO} from './model/PagedResourcesofCombinedClaimVO';
import {ClaimHistMaintHistUpdateVO} from './model/ClaimHistMaintHistUpdateVO';
import {ClaimHistMaintRequestUpdateVO} from './model/ClaimHistMaintRequestUpdateVO';
import {ReactivateClaimVO} from './model/ReactivateClaimVO';
import {DedAggrIndicatorVO} from './model/DedAggrIndicatorVO';
import {EobUpdateVO} from './model/EobUpdateVO';
import {DeleteClaimVO} from './model/DeleteClaimVO';
import {ClaimNoteVO} from './model/ClaimNoteVO';
import {ClaimHistMaintEligibilityVO} from './model/ClaimHistMaintEligibilityVO';

@Injectable({
  providedIn: 'root'
})
export class ClaimHistoryApi {

  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();
  protected basePath = '';

  constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }

  /**
   * Find Claim History by member number or claim number
   * To query claim history by 11 digit member number or claim number
   * @param requestCorrelationId Initial Request GUID
   * @param claimNumber Claim Number
   * @param membershipId Member AARP Membership ID
   * @param dosFrom Date of Service From (all dates &gt;&#x3D;)
   * @param dosTo Date of Service To (all dates &lt;&#x3D;)
   * @param billNpi Billing Provider NPI
   * @param claimHistStatus Claim History Status
   * @param typeOfService Type Of Service
   * @param sortBy sorting parameter
   * @param orderBy ordering parameter (search results reordering eg ascending)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findClaimHistory(requestCorrelationId?: string, claimNumber?: number, membershipId?: string, dosFrom?: string, dosTo?: string, billNpi?: string, claimHistStatus?: string, typeOfService?: string, sortBy?: string, orderBy?: string, size?: number, page?: number, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesOfResourceOfClaimHistoryVO>;
  public findClaimHistory(requestCorrelationId?: string, claimNumber?: number, membershipId?: string, dosFrom?: string, dosTo?: string, billNpi?: string, claimHistStatus?: string, typeOfService?: string, sortBy?: string, orderBy?: string, size?: number, page?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesOfResourceOfClaimHistoryVO>>;
  public findClaimHistory(requestCorrelationId?: string, claimNumber?: number, membershipId?: string, dosFrom?: string, dosTo?: string, billNpi?: string, claimHistStatus?: string, typeOfService?: string, sortBy?: string, orderBy?: string, size?: number, page?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesOfResourceOfClaimHistoryVO>>;
  public findClaimHistory(requestCorrelationId?: string, claimNumber?: number, membershipId?: string, dosFrom?: string, dosTo?: string, billNpi?: string, claimHistStatus?: string, typeOfService?: string, sortBy?: string, orderBy?: string, size?: number, page?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (claimNumber !== undefined) {
      queryParameters = queryParameters.set('claimNumber', <any>claimNumber);
    }
    if (membershipId !== undefined) {
      queryParameters = queryParameters.set('membership_id', <any>membershipId);
    }
    if (dosFrom !== undefined) {
      queryParameters = queryParameters.set('dos_from', <any>dosFrom);
    }
    if (dosTo !== undefined) {
      queryParameters = queryParameters.set('dos_to', <any>dosTo);
    }
    if (billNpi !== undefined) {
      queryParameters = queryParameters.set('bill_npi', <any>billNpi);
    }
    if (claimHistStatus !== undefined) {
      queryParameters = queryParameters.set('claim_hist_status', <any>claimHistStatus);
    }
    if (typeOfService !== undefined) {
      queryParameters = queryParameters.set('type_of_service', <any>typeOfService);
    }
    if (sortBy !== undefined) {
      queryParameters = queryParameters.set('sort_by', <any>sortBy);
    }
    if (orderBy !== undefined) {
      queryParameters = queryParameters.set('order_by', <any>orderBy);
    }
    if (size !== undefined) {
      queryParameters = queryParameters.set('size', <any>size);
    }
    if (page !== undefined) {
      queryParameters = queryParameters.set('page', <any>page);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (OAuth2) required
    // oauth required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesOfResourceOfClaimHistoryVO>(`${this.basePath}/api/claimhistory`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Find Members on claim history
   * To query claim history by 9 digit member number
   * @param requestCorrelationId Initial Request GUID
   * @param membershipId Member AARP Membership ID
   * @param dosFrom Date of Service From (all dates &gt;&#x3D;)
   * @param dosTo Date of Service To (all dates &lt;&#x3D;)
   * @param billNpi Billing Provider NPI
   * @param claimHistStatus Claim History Status
   * @param typeOfService Type Of Service
   * @param sortBy sorting parameter
   * @param orderBy ordering parameter (search results reordering eg ascending)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findClaimHistoryMember(requestCorrelationId?: string, membershipId?: string, dosFrom?: string, dosTo?: string, billNpi?: string, claimHistStatus?: string, typeOfService?: string, sortBy?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesOfResourceOfClaimHistoryMemberVO>;
  public findClaimHistoryMember(requestCorrelationId?: string, membershipId?: string, dosFrom?: string, dosTo?: string, billNpi?: string, claimHistStatus?: string, typeOfService?: string, sortBy?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesOfResourceOfClaimHistoryMemberVO>>;
  public findClaimHistoryMember(requestCorrelationId?: string, membershipId?: string, dosFrom?: string, dosTo?: string, billNpi?: string, claimHistStatus?: string, typeOfService?: string, sortBy?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesOfResourceOfClaimHistoryMemberVO>>;
  public findClaimHistoryMember(requestCorrelationId?: string, membershipId?: string, dosFrom?: string, dosTo?: string, billNpi?: string, claimHistStatus?: string, typeOfService?: string, sortBy?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (membershipId !== undefined) {
      queryParameters = queryParameters.set('membership_id', <any>membershipId);
    }
    if (dosFrom !== undefined) {
      queryParameters = queryParameters.set('dos_from', <any>dosFrom);
    }
    if (dosTo !== undefined) {
      queryParameters = queryParameters.set('dos_to', <any>dosTo);
    }
    if (billNpi !== undefined) {
      queryParameters = queryParameters.set('bill_npi', <any>billNpi);
    }
    if (claimHistStatus !== undefined) {
      queryParameters = queryParameters.set('claim_hist_status', <any>claimHistStatus);
    }
    if (typeOfService !== undefined) {
      queryParameters = queryParameters.set('type_of_service', <any>typeOfService);
    }
    if (sortBy !== undefined) {
      queryParameters = queryParameters.set('sort_by', <any>sortBy);
    }
    if (orderBy !== undefined) {
      queryParameters = queryParameters.set('order_by', <any>orderBy);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (OAuth2) required
    // oauth required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesOfResourceOfClaimHistoryMemberVO>(`${this.basePath}/api/claimhistory/member`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Get Claim by claim Id
   * To retrieve a claim history by claim Id
   * @param claimId Claim Id
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getClaimHistory(claimId: number, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<ResourceOfClaimHistoryDetailVO>;
  public getClaimHistory(claimId: number, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResourceOfClaimHistoryDetailVO>>;
  public getClaimHistory(claimId: number, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResourceOfClaimHistoryDetailVO>>;
  public getClaimHistory(claimId: number, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimId === null || claimId === undefined) {
      throw new Error('Required parameter claimId was null or undefined when calling getClaimHistory.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // authentication (OAuth2) required
    // oauth required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<ResourceOfClaimHistoryDetailVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * List Bill Lines
   * To retrieve a list of bill lines for a given claim id
   * @param claimId Claim ID
   * @param requestCorrelationId Initial Request GUID
   * @param size List Size
   * @param page Page Number
   * @param sortBy sorting parameter
   * @param orderBy ordering parameter (search results reordering eg ascending)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listBillLine(claimId: number, requestCorrelationId?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesOfResourceOfClaimBillLineVO>;
  public listBillLine(claimId: number, requestCorrelationId?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesOfResourceOfClaimBillLineVO>>;
  public listBillLine(claimId: number, requestCorrelationId?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesOfResourceOfClaimBillLineVO>>;
  public listBillLine(claimId: number, requestCorrelationId?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimId === null || claimId === undefined) {
      throw new Error('Required parameter claimId was null or undefined when calling listBillLine.');
    }

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (size !== undefined) {
      queryParameters = queryParameters.set('size', <any>size);
    }
    if (page !== undefined) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (sortBy !== undefined) {
      queryParameters = queryParameters.set('sort_by', <any>sortBy);
    }
    if (orderBy !== undefined) {
      queryParameters = queryParameters.set('order_by', <any>orderBy);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (OAuth2) required
    // oauth required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesOfResourceOfClaimBillLineVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimId))}/bill_line`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * List Bill Line Details
   * To retrieve a list of bill line details for a given claim number
   * @param claimNumber Claim Number
   * @param eobType EOB Type
   * @param billLineType Bill Line Type
   * @param requestCorrelationId Initial Request GUID
   * @param size List Size
   * @param page Page Number
   * @param sortBy sorting parameter
   * @param orderBy ordering parameter (search results reordering eg ascending)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listBillLineDetails(claimNumber: number, eobType: string, billLineType: string, requestCorrelationId?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesOfResourceOfClaimBillLineDetailsVO>;
  public listBillLineDetails(claimNumber: number, eobType: string, billLineType: string, requestCorrelationId?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesOfResourceOfClaimBillLineDetailsVO>>;
  public listBillLineDetails(claimNumber: number, eobType: string, billLineType: string, requestCorrelationId?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesOfResourceOfClaimBillLineDetailsVO>>;
  public listBillLineDetails(claimNumber: number, eobType: string, billLineType: string, requestCorrelationId?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling listBillLineDetails.');
    }
    if (eobType === null || eobType === undefined) {
      throw new Error('Required parameter eobType was null or undefined when calling listBillLineDetails.');
    }
    if (billLineType === null || billLineType === undefined) {
      throw new Error('Required parameter billLineType was null or undefined when calling listBillLineDetails.');
    }

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (eobType !== undefined) {
      queryParameters = queryParameters.set('eob_type', <any>eobType);
    }
    if (billLineType !== undefined) {
      queryParameters = queryParameters.set('bill_line_type', <any>billLineType);
    }
    if (size !== undefined) {
      queryParameters = queryParameters.set('size', <any>size);
    }
    if (page !== undefined) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (sortBy !== undefined) {
      queryParameters = queryParameters.set('sort_by', <any>sortBy);
    }
    if (orderBy !== undefined) {
      queryParameters = queryParameters.set('order_by', <any>orderBy);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (OAuth2) required
    // oauth required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesOfResourceOfClaimBillLineDetailsVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/bill_line_detail`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Get claim history audit details
   * To retrieve claim audit details for claim history
   * @param claimNumber Claim Number
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getClaimHistoryAudit(claimNumber: number, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<ClaimHistoryAuditVO>;
  public getClaimHistoryAudit(claimNumber: number, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClaimHistoryAuditVO>>;
  public getClaimHistoryAudit(claimNumber: number, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClaimHistoryAuditVO>>;
  public getClaimHistoryAudit(claimNumber: number, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling getClaimHistoryAudit.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // authentication (OAuth2) required
    // oauth required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<ClaimHistoryAuditVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/claim_audit`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Get claim history bill line messages
   * To retrieve claim messages in claim history
   * @param billLineKey Bill Line Key
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getClaimHistoryBillLineMessages(billLineKey: number, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesOfResourceOfClaimHistoryBillLineMessagesVO>;
  public getClaimHistoryBillLineMessages(billLineKey: number, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesOfResourceOfClaimHistoryBillLineMessagesVO>>;
  public getClaimHistoryBillLineMessages(billLineKey: number, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesOfResourceOfClaimHistoryBillLineMessagesVO>>;
  public getClaimHistoryBillLineMessages(billLineKey: number, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (billLineKey === null || billLineKey === undefined) {
      throw new Error('Required parameter billLineKey was null or undefined when calling getClaimHistoryBillLineMessages.');
    }

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (billLineKey !== undefined) {
      queryParameters = queryParameters.set('bill_line_key', <any>billLineKey);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesOfResourceOfClaimHistoryBillLineMessagesVO>(`${this.basePath}/api/claimhistory/bill_line_messages`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Get claim history claim messages
   * To retrieve claim messages in claim history
   * @param claimNumber Claim Number
   * @param requestCorrelationId Initial Request GUID
   * @param sortBy sorting parameter
   * @param orderBy ordering parameter
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getClaimHistoryClaimMessages(claimNumber: number, requestCorrelationId?: string, sortBy?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesOfResourceOfClaimHistoryClaimMessagesVO>;
  public getClaimHistoryClaimMessages(claimNumber: number, requestCorrelationId?: string, sortBy?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesOfResourceOfClaimHistoryClaimMessagesVO>>;
  public getClaimHistoryClaimMessages(claimNumber: number, requestCorrelationId?: string, sortBy?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesOfResourceOfClaimHistoryClaimMessagesVO>>;
  public getClaimHistoryClaimMessages(claimNumber: number, requestCorrelationId?: string, sortBy?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling getClaimHistoryClaimMessages.');
    }

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sortBy !== undefined) {
      queryParameters = queryParameters.set('sort_by', <any>sortBy);
    }
    if (orderBy !== undefined) {
      queryParameters = queryParameters.set('order_by', <any>orderBy);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesOfResourceOfClaimHistoryClaimMessagesVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/claim_messages`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Get list of cross references
   * To retrieve list of cross references for a claim
   * @param claimNumber Claim Number
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCrossReference(claimNumber: number, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesOfResourcesListOfResourceOfCrossReferenceVO>;
  public getCrossReference(claimNumber: number, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesOfResourcesListOfResourceOfCrossReferenceVO>>;
  public getCrossReference(claimNumber: number, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesOfResourcesListOfResourceOfCrossReferenceVO>>;
  public getCrossReference(claimNumber: number, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling getCrossReference.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (claimNumber !== undefined) {
      queryParameters = queryParameters.set('claimNumber', <any>claimNumber);
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesOfResourcesListOfResourceOfCrossReferenceVO>(`${this.basePath}/api/claim/crossreference`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Create a cross reference record using claim number
   * Create cross reference entry using claim number
   * @param claimNumber Claim Number
   * @param crossReference To create a cross reference
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createClaimHistoryCrossReference(claimNumber: number, crossReference: CrossReferenceVO, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<CrossReferenceVO>;
  public createClaimHistoryCrossReference(claimNumber: number, crossReference: CrossReferenceVO, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CrossReferenceVO>>;
  public createClaimHistoryCrossReference(claimNumber: number, crossReference: CrossReferenceVO, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CrossReferenceVO>>;
  public createClaimHistoryCrossReference(claimNumber: number, crossReference: CrossReferenceVO, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling createClaimHistoryCrossReference.');
    }
    if (crossReference === null || crossReference === undefined) {
      throw new Error('Required parameter crossReference was null or undefined when calling createClaimHistoryCrossReference.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<CrossReferenceVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/add_cross_reference`,
      crossReference,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Determine if claim EOB and RA can be sent or replaced
   * To retrieve if a claim is eligible to have EOB and RA sent or replaced
   * @param claimNumber Claim Number
   * @param requestCorrelationId Initial Request GUID
   * @param sendReplaceIndicator Send Replace Indicator
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public determineSendReplaceEobRaEligibility(claimNumber: number, requestCorrelationId?: string, sendReplaceIndicator?: string, observe?: 'body', reportProgress?: boolean): Observable<ClaimHistorySendReplaceEobRaEligibleVO>;
  public determineSendReplaceEobRaEligibility(claimNumber: number, requestCorrelationId?: string, sendReplaceIndicator?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClaimHistorySendReplaceEobRaEligibleVO>>;
  public determineSendReplaceEobRaEligibility(claimNumber: number, requestCorrelationId?: string, sendReplaceIndicator?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClaimHistorySendReplaceEobRaEligibleVO>>;
  public determineSendReplaceEobRaEligibility(claimNumber: number, requestCorrelationId?: string, sendReplaceIndicator?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling determineSendReplaceEobRaEligibility.');
    }

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sendReplaceIndicator !== undefined) {
      queryParameters = queryParameters.set('sendReplaceIndicator', <any>sendReplaceIndicator);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<ClaimHistorySendReplaceEobRaEligibleVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/send_eob_ra`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Identify claims for the print jobs for send and replace EOB and RAs
   * To post claim numbers to tables maintaining inventory of claims to send and replace EOB and RAs
   * @param claimNumber Claim Number
   * @param sendReplaceIndicator Send Replace Indicator
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public sendMultiSendReplaceEobRa(claimNumber: Array<number>, sendReplaceIndicator: string, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<ResourcesListOfResourceOfSendReplaceConfirmationVO>;
  public sendMultiSendReplaceEobRa(claimNumber: Array<number>, sendReplaceIndicator: string, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResourcesListOfResourceOfSendReplaceConfirmationVO>>;
  public sendMultiSendReplaceEobRa(claimNumber: Array<number>, sendReplaceIndicator: string, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResourcesListOfResourceOfSendReplaceConfirmationVO>>;
  public sendMultiSendReplaceEobRa(claimNumber: Array<number>, sendReplaceIndicator: string, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling sendMultiSendReplaceEobRa.');
    }
    if (sendReplaceIndicator === null || sendReplaceIndicator === undefined) {
      throw new Error('Required parameter sendReplaceIndicator was null or undefined when calling sendMultiSendReplaceEobRa.');
    }

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (claimNumber) {
      claimNumber.forEach((element) => {
        queryParameters = queryParameters.append('claimNumber', <any>element);
      });
    }
    if (sendReplaceIndicator !== undefined) {
      queryParameters = queryParameters.set('sendReplaceIndicator', <any>sendReplaceIndicator);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.post<ResourcesListOfResourceOfSendReplaceConfirmationVO>(`${this.basePath}/api/claimhistory/send_eob_ra`,
      null,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Determine if multiple claims&#39; EOB and RA can be sent or replaced
   * To retrieve if multiple claims are eligible to have EOB and RA sent or replaced
   * @param claimNumber Claim Number
   * @param requestCorrelationId Initial Request GUID
   * @param sendReplaceIndicator Send Replace Indicator
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public determineMultiSendReplaceEobRaEligibility(claimNumber: Array<number>, requestCorrelationId?: string, sendReplaceIndicator?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesOfResourcesListOfResourceOfClaimHistorySendReplaceEobRaEligibleVO>;
  public determineMultiSendReplaceEobRaEligibility(claimNumber: Array<number>, requestCorrelationId?: string, sendReplaceIndicator?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesOfResourcesListOfResourceOfClaimHistorySendReplaceEobRaEligibleVO>>;
  public determineMultiSendReplaceEobRaEligibility(claimNumber: Array<number>, requestCorrelationId?: string, sendReplaceIndicator?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesOfResourcesListOfResourceOfClaimHistorySendReplaceEobRaEligibleVO>>;
  public determineMultiSendReplaceEobRaEligibility(claimNumber: Array<number>, requestCorrelationId?: string, sendReplaceIndicator?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling determineMultiSendReplaceEobRaEligibility.');
    }

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (claimNumber) {
      claimNumber.forEach((element) => {
        queryParameters = queryParameters.append('claimNumber', <any>element);
      });
    }
    if (sendReplaceIndicator !== undefined) {
      queryParameters = queryParameters.set('sendReplaceIndicator', <any>sendReplaceIndicator);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesOfResourcesListOfResourceOfClaimHistorySendReplaceEobRaEligibleVO>(`${this.basePath}/api/claimhistory/send_eob_ra`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Retrieve ACH payment information on a claim history claim
   * To retrieve ACH payment information on a claim in claim history
   * @param claimNumber Claim Number
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public viewAchPayment(claimNumber: number, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<ClaimHistoryAchPaymentVO>;
  public viewAchPayment(claimNumber: number, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClaimHistoryAchPaymentVO>>;
  public viewAchPayment(claimNumber: number, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClaimHistoryAchPaymentVO>>;
  public viewAchPayment(claimNumber: number, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling viewAchPayment.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<ClaimHistoryAchPaymentVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/ach_payment`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Transfers claim from one member to another
   * To transfer a claim from one member to another
   * @param claimNumber Claim Number
   * @param newMemberNumber New Member Number
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public transferClaim(claimNumber: number, newMemberNumber: string, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<TransferClaimVO>;
  public transferClaim(claimNumber: number, newMemberNumber: string, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransferClaimVO>>;
  public transferClaim(claimNumber: number, newMemberNumber: string, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransferClaimVO>>;
  public transferClaim(claimNumber: number, newMemberNumber: string, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling transferClaim.');
    }
    if (newMemberNumber === null || newMemberNumber === undefined) {
      throw new Error('Required parameter newMemberNumber was null or undefined when calling transferClaim.');
    }

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (newMemberNumber !== undefined) {
      queryParameters = queryParameters.set('newMemberNumber', <any>newMemberNumber);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.put<TransferClaimVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/transfer_claim`,
      null,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Returns paginated list of maintenance requests
   * To get paginated list of maintenance requests
   * @param requestCorrelationId Initial Request GUID
   * @param team Team Code
   * @param msid Requesting user MSID
   * @param actionType Maintenance Action
   * @param requestStatus Request Status
   * @param size List Size
   * @param page Page Number
   * @param sortBy sorting parameter
   * @param orderBy search results reordering eg ascending
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getMaintenanceRequests(requestCorrelationId?: string, team?: string, msid?: string, actionType?: string, requestStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesofResourceOfClaimHistMaintHistVO>;
  public getMaintenanceRequests(requestCorrelationId?: string, team?: string, msid?: string, actionType?: string, requestStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesofResourceOfClaimHistMaintHistVO>>;
  public getMaintenanceRequests(requestCorrelationId?: string, team?: string, msid?: string, actionType?: string, requestStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesofResourceOfClaimHistMaintHistVO>>;
  public getMaintenanceRequests(requestCorrelationId?: string, team?: string, msid?: string, actionType?: string, requestStatus?: string, size?: number, page?: number, sortBy?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (team !== undefined) {
      queryParameters = queryParameters.set('team', <any>team);
    }
    if (msid !== undefined) {
      queryParameters = queryParameters.set('msid', <any>msid);
    }
    if (actionType !== undefined) {
      queryParameters = queryParameters.set('action_type', <any>actionType);
    }
    if (requestStatus !== undefined) {
      queryParameters = queryParameters.set('request_status', <any>requestStatus);
    }
    if (size !== undefined) {
      queryParameters = queryParameters.set('size', <any>size);
    }
    if (page !== undefined) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (sortBy !== undefined) {
      queryParameters = queryParameters.set('sort_by', <any>sortBy);
    }
    if (orderBy !== undefined) {
      queryParameters = queryParameters.set('order_by', <any>orderBy);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesofResourceOfClaimHistMaintHistVO>(`${this.basePath}/api/claimhistory/maintenance_requests`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Returns claim lock status
   * To get claim lock status
   * @param claimNumber Claim Number
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getClaimLockStatus(claimNumber: number, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<ClaimLockVO>;
  public getClaimLockStatus(claimNumber: number, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClaimLockVO>>;
  public getClaimLockStatus(claimNumber: number, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClaimLockVO>>;
  public getClaimLockStatus(claimNumber: number, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling getClaimLockStatus.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<ClaimLockVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/claim_lock`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Returns paginated list of maintenance requests
   * To get paginated list of maintenance requests
   * @param requestCorrelationId Initial Request GUID
   * @param actionType Maintenance Action
   * @param maintRequestId Request Status
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getMaintRequest(requestCorrelationId?: string, actionType?: string, maintRequestId?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesofResourceOfDisplayRequestVO>;
  public getMaintRequest(requestCorrelationId?: string, actionType?: string, maintRequestId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesofResourceOfDisplayRequestVO>>;
  public getMaintRequest(requestCorrelationId?: string, actionType?: string, maintRequestId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesofResourceOfDisplayRequestVO>>;
  public getMaintRequest(requestCorrelationId?: string, actionType?: string, maintRequestId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (actionType !== undefined) {
      queryParameters = queryParameters.set('action_type', <any>actionType);
    }
    if (maintRequestId !== undefined) {
      queryParameters = queryParameters.set('maint_request_id', <any>maintRequestId);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesofResourceOfDisplayRequestVO>(`${this.basePath}/api/claimhistory/display_request`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

   /**
     * Returns list of combined claims
     * To get list of combined claims
     * @param requestCorrelationId Initial Request GUID
     * @param claimNumber Claim Number
     * @param combinedClaimType combined claim Type
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
  public getCombinedClaims(requestCorrelationId: string, claimNumber: number, combinedClaimType: 'INSURED' | 'PROVIDER', observe?: 'body', reportProgress?: boolean): Observable<PagedResourcesofCombinedClaimVO>;
  public getCombinedClaims(requestCorrelationId: string, claimNumber: number, combinedClaimType: 'INSURED' | 'PROVIDER', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResourcesofCombinedClaimVO>>;
  public getCombinedClaims(requestCorrelationId: string, claimNumber: number, combinedClaimType: 'INSURED' | 'PROVIDER', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResourcesofCombinedClaimVO>>;
  public getCombinedClaims(requestCorrelationId: string, claimNumber: number, combinedClaimType: 'INSURED' | 'PROVIDER', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

    if (requestCorrelationId === null || requestCorrelationId === undefined) {
      throw new Error('Required parameter requestCorrelationId was null or undefined when calling getCombinedClaims.');
    }

    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling getCombinedClaims.');
    }

    if (combinedClaimType === null || combinedClaimType === undefined) {
      throw new Error('Required parameter combinedClaimType was null or undefined when calling getCombinedClaims.');
    }

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (combinedClaimType !== undefined && combinedClaimType !== null) {
      queryParameters = queryParameters.set('combinedClaimType', <any>combinedClaimType);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<PagedResourcesofCombinedClaimVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/combined_claims`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Update a maintenance request
   * To update a maintenance request
   * @param maintenanceRequestUpdate To update a maint request
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateMaintRequest(maintenanceRequestUpdate: ClaimHistMaintRequestUpdateVO, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<ClaimHistMaintHistUpdateVO>;
  public updateMaintRequest(maintenanceRequestUpdate: ClaimHistMaintRequestUpdateVO, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClaimHistMaintHistUpdateVO>>;
  public updateMaintRequest(maintenanceRequestUpdate: ClaimHistMaintRequestUpdateVO, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClaimHistMaintHistUpdateVO>>;
  public updateMaintRequest(maintenanceRequestUpdate: ClaimHistMaintRequestUpdateVO, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

    if (maintenanceRequestUpdate === null || maintenanceRequestUpdate === undefined) {
      throw new Error('Required parameter maintenanceRequestUpdate was null or undefined when calling updateMaintRequest.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.put<ClaimHistMaintHistUpdateVO>(`${this.basePath}/api/claimhistory/maintenance_requests`,
      maintenanceRequestUpdate,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }
  /**
   * Updates claim history claim status to Disbursed or Suspended according to reactivate claim rules
   * To update claim history claim status to disbursed or suspended per reactivate claim rules
   * @param requestCorrelationId Initial Request GUID
   * @param claimNumber Claim Number
   * @param reactivateClaim To provide deductible aggregate indicator needed for reactivate process
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public reactivateClaim(requestCorrelationId: string, claimNumber: number, reactivateClaim: DedAggrIndicatorVO, observe?: 'body', reportProgress?: boolean): Observable<ReactivateClaimVO>;
  public reactivateClaim(requestCorrelationId: string, claimNumber: number, reactivateClaim: DedAggrIndicatorVO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ReactivateClaimVO>>;
  public reactivateClaim(requestCorrelationId: string, claimNumber: number, reactivateClaim: DedAggrIndicatorVO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ReactivateClaimVO>>;
  public reactivateClaim(requestCorrelationId: string, claimNumber: number, reactivateClaim: DedAggrIndicatorVO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

    if (requestCorrelationId === null || requestCorrelationId === undefined) {
      throw new Error('Required parameter requestCorrelationId was null or undefined when calling reactivateClaim.');
    }

    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling reactivateClaim.');
    }

    if (reactivateClaim === null || reactivateClaim === undefined) {
      throw new Error('Required parameter reactivateClaim was null or undefined when calling reactivateClaim.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.put<ReactivateClaimVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/reactivate_claim`,
      reactivateClaim,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }
  /**
   * Updates EOB claim and bill line fields in a claim
   * To update EOB values at claim and bill line level
   * @param claimNumber Claim Number
   * @param eobUpdate To update values in an Eob
   * @param requestCorrelationId Initial Request GUID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateEob(claimNumber: number, eobUpdate: EobUpdateVO, requestCorrelationId?: string, observe?: 'body', reportProgress?: boolean): Observable<EobUpdateVO>;
  public updateEob(claimNumber: number, eobUpdate: EobUpdateVO, requestCorrelationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EobUpdateVO>>;
  public updateEob(claimNumber: number, eobUpdate: EobUpdateVO, requestCorrelationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EobUpdateVO>>;
  public updateEob(claimNumber: number, eobUpdate: EobUpdateVO, requestCorrelationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling updateEob.');
    }

    if (eobUpdate === null || eobUpdate === undefined) {
      throw new Error('Required parameter eobUpdate was null or undefined when calling updateEob.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.put<EobUpdateVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/update_eob`,
      eobUpdate,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Updates claim history claim status to Deleted
   * To update claim history claim status to deleted
   * @param requestCorrelationId Initial Request GUID
   * @param claimNumber Claim Number
   * @param noteUpdateIndicator Note Update Indicator
   * @param claimNoteUpdate To update values in a claim note in delete maintenance
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteClaim(requestCorrelationId: string, claimNumber: number, noteUpdateIndicator: 'Y' | 'N', claimNoteUpdate: ClaimNoteVO, observe?: 'body', reportProgress?: boolean): Observable<DeleteClaimVO>;
  public deleteClaim(requestCorrelationId: string, claimNumber: number, noteUpdateIndicator: 'Y' | 'N', claimNoteUpdate: ClaimNoteVO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteClaimVO>>;
  public deleteClaim(requestCorrelationId: string, claimNumber: number, noteUpdateIndicator: 'Y' | 'N', claimNoteUpdate: ClaimNoteVO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteClaimVO>>;
  public deleteClaim(requestCorrelationId: string, claimNumber: number, noteUpdateIndicator: 'Y' | 'N', claimNoteUpdate: ClaimNoteVO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

    if (requestCorrelationId === null || requestCorrelationId === undefined) {
      throw new Error('Required parameter requestCorrelationId was null or undefined when calling deleteClaim.');
    }

    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling deleteClaim.');
    }

    if (noteUpdateIndicator === null || noteUpdateIndicator === undefined) {
      throw new Error('Required parameter noteUpdateIndicator was null or undefined when calling deleteClaim.');
    }

    if (claimNoteUpdate === null || claimNoteUpdate === undefined) {
      throw new Error('Required parameter claimNoteUpdate was null or undefined when calling deleteClaim.');
    }

    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (noteUpdateIndicator !== undefined && noteUpdateIndicator !== null) {
      queryParameters = queryParameters.set('noteUpdateIndicator', <any>noteUpdateIndicator);
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.put<DeleteClaimVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/delete_claim`,
      claimNoteUpdate,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Returns claim history maintenance eligibility
   * To get claim history maintenance eligibility
   * @param requestCorrelationId Initial Request GUID
   * @param claimNumber Claim Number
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getClaimHistMaintEligibility(requestCorrelationId: string, claimNumber: number, observe?: 'body', reportProgress?: boolean): Observable<ClaimHistMaintEligibilityVO>;
  public getClaimHistMaintEligibility(requestCorrelationId: string, claimNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClaimHistMaintEligibilityVO>>;
  public getClaimHistMaintEligibility(requestCorrelationId: string, claimNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClaimHistMaintEligibilityVO>>;
  public getClaimHistMaintEligibility(requestCorrelationId: string, claimNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

    if (requestCorrelationId === null || requestCorrelationId === undefined) {
      throw new Error('Required parameter requestCorrelationId was null or undefined when calling getClaimHistMaintEligibility.');
    }

    if (claimNumber === null || claimNumber === undefined) {
      throw new Error('Required parameter claimNumber was null or undefined when calling getClaimHistMaintEligibility.');
    }

    let headers = this.defaultHeaders;
    if (requestCorrelationId !== undefined && requestCorrelationId !== null) {
      headers = headers.set('RequestCorrelationId', String(requestCorrelationId));
    }

    // authentication (oauth) required
    if (this.configuration.accessToken) {
      const accessToken = typeof this.configuration.accessToken === 'function'
        ? this.configuration.accessToken()
        : this.configuration.accessToken;
      headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }

    // to determine the Accept header
    const httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];

    return this.httpClient.get<ClaimHistMaintEligibilityVO>(`${this.basePath}/api/claimhistory/${encodeURIComponent(String(claimNumber))}/maintenance_eligibility`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }
}
